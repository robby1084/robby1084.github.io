<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java学习-Nio Selector | JunDa Chen's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java学习-Nio Selector</h1><a id="logo" href="/.">JunDa Chen's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java学习-Nio Selector</h1><div class="post-meta">Jul 30, 2017<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Selector简介"><span class="toc-number">1.</span> <span class="toc-text">Selector简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector"><span class="toc-number">1.1.</span> <span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectableChannel"><span class="toc-number">1.2.</span> <span class="toc-text">SelectableChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectionKey"><span class="toc-number">1.3.</span> <span class="toc-text">SelectionKey</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selector使用"><span class="toc-number">2.</span> <span class="toc-text">Selector使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、创建Selector"><span class="toc-number">2.1.</span> <span class="toc-text">1、创建Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、将Channel注册到Selector"><span class="toc-number">2.2.</span> <span class="toc-text">2、将Channel注册到Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、为SelectionKey绑定附加对象"><span class="toc-number">2.3.</span> <span class="toc-text">3、为SelectionKey绑定附加对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、通过Selector选择通道"><span class="toc-number">2.4.</span> <span class="toc-text">4、通过Selector选择通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#已注册的键的集合-Registered-key-set"><span class="toc-number">2.4.1.</span> <span class="toc-text">已注册的键的集合(Registered key set)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#已选择的键的集合-Selected-key-set"><span class="toc-number">2.4.2.</span> <span class="toc-text">已选择的键的集合(Selected key set)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#已取消的键的集合-Cancelled-key-set"><span class="toc-number">2.4.3.</span> <span class="toc-text">已取消的键的集合(Cancelled key set)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于Selector执行选择的过程"><span class="toc-number">2.4.4.</span> <span class="toc-text">关于Selector执行选择的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#已注册键集合的管理"><span class="toc-number">2.4.5.</span> <span class="toc-text">已注册键集合的管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、停止选择"><span class="toc-number">2.5.</span> <span class="toc-text">5、停止选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selector完整实例"><span class="toc-number">3.</span> <span class="toc-text">Selector完整实例</span></a></li></ol></div></div><div class="post-content"><h2 id="Selector简介"><a href="#Selector简介" class="headerlink" title="Selector简介"></a>Selector简介</h2><p>选择器提供选择执行已经就绪的任务的能力.从底层来看，Selector提供了询问通道是否已经准备好执行每个I/O操作的能力。Selector 允许单线程处理多个Channel。仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道，这样会大量的减少线程之间上下文切换的开销。</p>
<p>在开始之前，需要回顾一下Selector、SelectableChannel和SelectionKey：</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Selector选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的，并且使用选择器来更新通道的就绪状态。当这么做的时候，可以选择将被激发的线程挂起，直到有就绪的的通道。</div></pre></td></tr></table></figure>
<h3 id="SelectableChannel"><a href="#SelectableChannel" class="headerlink" title="SelectableChannel"></a>SelectableChannel</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SelectableChannel这个抽象类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。因为FileChannel类没有继承SelectableChannel因此是不是可选通道，而所有socket通道都是可选择的，包括从管道(Pipe)对象的中获得的通道。SelectableChannel可以被注册到Selector对象上，同时可以指定对那个选择器而言，那种操作是感兴趣的。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</div></pre></td></tr></table></figure>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码)，指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。</div></pre></td></tr></table></figure>
<h2 id="Selector使用"><a href="#Selector使用" class="headerlink" title="Selector使用"></a>Selector使用</h2><h3 id="1、创建Selector"><a href="#1、创建Selector" class="headerlink" title="1、创建Selector"></a>1、创建Selector</h3><p>Selector对象是通过调用静态工厂方法open()来实例化的，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ Selector Selector=Selector.open()；</div></pre></td></tr></table></figure></p>
<p>类方法open()实际上向SPI1发出请求，通过默认的SelectorProvider对象获取一个新的实例。</p>
<h3 id="2、将Channel注册到Selector"><a href="#2、将Channel注册到Selector" class="headerlink" title="2、将Channel注册到Selector"></a>2、将Channel注册到Selector</h3><p>要实现Selector管理Channel，需要将channel注册到相应的Selector上，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ channel.configureBlocking(<span class="literal">false</span>);</div><div class="line">$ SelectionKey key= channel.register(selector,SelectionKey,OP_READ);</div></pre></td></tr></table></figure></p>
<p>通过调用通道的register()方法会将它注册到一个选择器上。与Selector一起使用时，Channel必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道都可以。另外通道一旦被注册，将不能再回到阻塞状态，此时若调用通道的configureBlocking(true)将抛出BlockingModeException异常。<br>register()方法的第二个参数是“interest集合”，表示选择器所关心的通道操作，它实际上是一个表示选择器在检查通道就绪状态时需要关心的操作的比特掩码。比如一个选择器对通道的read和write操作感兴趣，那么选择器在检查该通道时，只会检查通道的read和write操作是否已经处在就绪状态。<br>Selector有四种操作</p>
<ul>
<li>Connct连接</li>
<li>Accept接受</li>
<li>Read读</li>
<li>Write写</li>
</ul>
<p>需要注意并非所有的操作在所有的可选择通道上都能被支持，比如ServerSocketChannel支持Accept，而SocketChannel中不支持。我们可以通过通道上的validOps()方法来获取特定通道下所有支持的操作集合。<br>Java中定义了四个常量来表示这四种操作类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ SelectionKey.OP_CONNECT</div><div class="line">$ SelectionKey.OP_ACCEPT</div><div class="line">$ SelectionKey.OP_READ</div><div class="line">$ SelectionKey.OP_WRITE</div></pre></td></tr></table></figure></p>
<p>如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int interestSet=SelectionKey.OP_READ|SelectionKey.OP_WRITE</div></pre></td></tr></table></figure><br>当通道触发了某个操作之后，表示该通道的某个操作已经就绪，可以被操作。因此，某个SocketChannel成功连接到另一个服务器称为“连接就绪”(OP_CONNECT)。一个ServerSocketChannel准备好接收新进入的连接称为“接收就绪”（OP_ACCEPT）。一个有数据可读的通道可以说是“读就绪”(OP_READ)。等待写数据的通道可以说是“写就绪”(OP_WRITE)。<br>register()方法会返回一个SelectionKey对象，我们称之为键对象。该对象包含了以下四种属性：</p>
<ul>
<li>interest集合</li>
<li>read集合</li>
<li>Channel</li>
<li>Selector</li>
</ul>
<p>interest集合是Selector感兴趣的集合，用于指示选择器对通道关心的操作，可通过SelectionKey对象的interestOps()获取。最初，该兴趣集合是通道被注册到Selector时传进来的值。该集合不会被选择器改变，但是可通过interestOps()改变。我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ int interestSet=selectionKey.interestOps();</div><div class="line">$ boolean isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</div></pre></td></tr></table></figure></p>
<p>read集合是通道已经就绪的操作的集合，表示一个通道准备好要执行的操作了,可通过SelctionKey对象的readyOps()来获取相关通道已经就绪的操作。它是interest集合的子集，并且表示了interest集合中从上次调用select()以后已经就绪的那些操作。（比如选择器对通道的read,write操作感兴趣，而某时刻通道的read操作已经准备就绪可以被选择器获知了，前一种就是interest集合，后一种则是read集合。）。JAVA中定义以下几个方法用来检查这些操作是否就绪：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ selectionKey.isAcceptable();//等价于selectionKey.readyOps()&amp;SelectionKey.OP_ACCEPT</div><div class="line">$ selectionKey.isConnectable();</div><div class="line">$ selectionKey.isReadable();</div><div class="line">$ selectionKey.isWritable();</div></pre></td></tr></table></figure></p>
<p>需要注意的是，通过相关的选择键的readyOps()方法返回的就绪状态指示只是一个提示，底层的通道在任何时候都会不断改变，而其他线程也可能在通道上执行操作并影响到它的就绪状态。另外，我们不能直接修改read集合。<br>通过SelectionKey访问对应的Selector和Channel：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ Channel channel =selectionKey.channel();</div><div class="line">$ Selector selector=selectionKey.selector();</div></pre></td></tr></table></figure></p>
<p>我们可以通过SelectionKey对象的cancel()方法来取消特定的注册关系。该方法调用之后，该SelectionKey对象将会被”拷贝”至已取消键的集合中，该键此时已经失效，但是该注册关系并不会立刻终结。在下一次select()时，已取消键的集合中的元素会被清除，相应的注册关系也真正终结。</p>
<h3 id="3、为SelectionKey绑定附加对象"><a href="#3、为SelectionKey绑定附加对象" class="headerlink" title="3、为SelectionKey绑定附加对象"></a>3、为SelectionKey绑定附加对象</h3><p>可以将一个或者多个附加对象绑定到SelectionKey上，以便容易的识别给定的通道。通常有两种方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ 在注册的时候绑定 SelectionKey key=channel.register(selector,SelectionKey.OP_READ,theObject);</div><div class="line">$ 在绑定完成之后附加 selectionKey.attach(theObject);//绑定</div></pre></td></tr></table></figure></p>
<p>需要注意的是如果附加的对象不再使用，一定要人为清除，因为垃圾回收器不会回收该对象，若不清除的话会成内存泄漏。<br>一个单独的通道可被注册到多个选择器中，有些时候我们需要通过isRegistered（）方法来检查一个通道是否已经被注册到任何一个选择器上。 通常来说，我们并不会这么做。</p>
<h3 id="4、通过Selector选择通道"><a href="#4、通过Selector选择通道" class="headerlink" title="4、通过Selector选择通道"></a>4、通过Selector选择通道</h3><p>我们知道选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中。接下来我们简单的了解一下Selector维护的三种类型SelectionKey集合：</p>
<h4 id="已注册的键的集合-Registered-key-set"><a href="#已注册的键的集合-Registered-key-set" class="headerlink" title="已注册的键的集合(Registered key set)"></a>已注册的键的集合(Registered key set)</h4><p>所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过keys()方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。</p>
<h4 id="已选择的键的集合-Selected-key-set"><a href="#已选择的键的集合-Selected-key-set" class="headerlink" title="已选择的键的集合(Selected key set)"></a>已选择的键的集合(Selected key set)</h4><p>已注册的键的集合的子集。这个集合的每个成员都是相关的通道被选择器(在前一个选择操作中)判断为已经准备好的，并且包含于键的interest集合中的操作。这个集合通过selectedKeys()方法返回(并有可能是空的)。<br>不要将已选择的键的集合与ready集合弄混了。这是一个键的集合，每个键都关联一个已经准备好至少一种操作的通道。每个键都有一个内嵌的ready集合，指示了所关联的通道已经准备好的操作。键可以直接从这个集合中移除，但不能添加。试图向已选择的键的集合中添加元素将抛出java.lang.UnsupportedOperationException。</p>
<h4 id="已取消的键的集合-Cancelled-key-set"><a href="#已取消的键的集合-Cancelled-key-set" class="headerlink" title="已取消的键的集合(Cancelled key set)"></a>已取消的键的集合(Cancelled key set)</h4><p>已注册的键的集合的子集，这个集合包含了cancel()方法被调用过的键(这个键已经被无效化)，但它们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。</p>
<hr>
<p>在刚初始化的Selector对象中，这三个集合都是空的。通过Selector的select（）方法可以选择已经准备就绪的通道（这些通道包含你感兴趣的的事件）。比如你对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。下面是Selector几个重载的select()方法：</p>
<ul>
<li>select():阻塞到至少有一个通道在你注册的事件上就绪了。</li>
<li>select(long timeout)：和select()一样，但最长阻塞事件为timeout毫秒。</li>
<li>selectNow():非阻塞，只要有通道就绪就立刻返回。</li>
</ul>
<p>select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。例如：首次调用select()方法，如果有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。<br>一旦调用select()方法，并且返回值不为0时，则可以通过调用Selector的selectedKeys()方法来访问已选择键集合。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set selectedKeys=selector.selectedKeys();</div></pre></td></tr></table></figure><br>进而可以放到和某SelectionKey关联的Selector和Channel。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Set selectedKeys = selector.selectedKeys();</div><div class="line">Iterator keyIterator = selectedKeys.iterator();</div><div class="line">while(keyIterator.hasNext()) &#123;</div><div class="line">    SelectionKey key = keyIterator.next();</div><div class="line">    if(key.isAcceptable()) &#123;</div><div class="line">        // a connection was accepted by a ServerSocketChannel.</div><div class="line">    &#125; else if (key.isConnectable()) &#123;</div><div class="line">        // a connection was established with a remote server.</div><div class="line">    &#125; else if (key.isReadable()) &#123;</div><div class="line">        // a channel is ready for reading</div><div class="line">    &#125; else if (key.isWritable()) &#123;</div><div class="line">        // a channel is ready for writing</div><div class="line">    &#125;</div><div class="line">    keyIterator.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="关于Selector执行选择的过程"><a href="#关于Selector执行选择的过程" class="headerlink" title="关于Selector执行选择的过程"></a>关于Selector执行选择的过程</h4><p>当select（）被调用时将执行以下几步：</p>
<ol>
<li>首先检查已取消键集合，也就是通过cancle()取消的键。如果该集合不为空，则清空该集合里的键，同时该集合中每个取消的键也将从已注册键集合和已选择键集合中移除。（一个键被取消时，并不会立刻从集合中移除，而是将该键“拷贝”至已取消键集合中，这种取消策略就是我们常提到的“延迟取消”。）</li>
<li>再次检查已注册键集合（准确说是该集合中每个键的interest集合）。系统底层会依次询问每个已经注册的通道是否准备好选择器所感兴趣的某种操作，一旦发现某个通道已经就绪了，则会首先判断该通道是否已经存在在已选择键集合当中，如果已经存在，则更新该通道在已注册键集合中对应的键的ready集合，如果不存在，则首先清空该通道的对应的键的ready集合，然后重设ready集合，最后将该键存至已注册键集合中。这里需要明白，当更新ready集合时，在上次select（）中已经就绪的操作不会被删除，也就是ready集合中的元素是累积的，比如在第一次的selector对某个通道的read和write操作感兴趣，在第一次执行select（）时，该通道的read操作就绪，此时该通道对应的键中的ready集合存有read元素，在第二次执行select()时，该通道的write操作也就绪了，此时该通道对应的ready集合中将同时有read和write元素。</li>
</ol>
<h4 id="已注册键集合的管理"><a href="#已注册键集合的管理" class="headerlink" title="已注册键集合的管理"></a>已注册键集合的管理</h4><p>选择器不会主动删除被添加到已选择键集合中的键，而且被添加到已选择键集合中的键的ready集合只能被设置，而不能被清理。如果我们希望清空已选择键集合中某个键的ready集合该怎么办？我们知道一个键在新加入已选择键集合之前会首先置空该键的ready集合，这样的话我们可以人为的将某个键从已注册键集合中移除最终实现置空某个键的ready集合。被移除的键如果在下一次的select（）中再次就绪，它将会重新被添加到已选择的键的集合中。这就是为什么要在每次迭代的末尾调用keyIterator.remove()。</p>
<h3 id="5、停止选择"><a href="#5、停止选择" class="headerlink" title="5、停止选择"></a>5、停止选择</h3><p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在select()方法中阻塞的线程。</p>
<ol>
<li>通过调用Selector对象的wakeup()方法让处在阻塞状态的select()方法立刻返回<br>该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。</li>
<li>通过close()方法关闭Selector<br>该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似wakeup()），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</li>
<li>调用interrupt()<br>调用该方法会使睡眠的线程抛出InterruptException异常，捕获该异常并在调用wakeup()</li>
</ol>
<h2 id="Selector完整实例"><a href="#Selector完整实例" class="headerlink" title="Selector完整实例"></a>Selector完整实例</h2><p>结合ServerSocketChannel和Selector构建简单的服务器，下面是完整的代码示例。<br>Server Terminal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">public class ServerSocketChannelTest &#123;</div><div class="line"></div><div class="line">    private int size = 1024;</div><div class="line">    private ServerSocketChannel socketChannel;</div><div class="line">    private ByteBuffer byteBuffer;</div><div class="line">    private Selector selector;</div><div class="line">    private final int port = 8998;</div><div class="line">    private int remoteClientNum=0;</div><div class="line"></div><div class="line">    public ServerSocketChannelTest() &#123;</div><div class="line">        try &#123;</div><div class="line">            initChannel();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            System.exit(-1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void initChannel() throws Exception &#123;</div><div class="line">        socketChannel = ServerSocketChannel.open();</div><div class="line">        socketChannel.configureBlocking(false);</div><div class="line">        socketChannel.bind(new InetSocketAddress(port));</div><div class="line">        System.out.println(&quot;listener on port:&quot; + port);</div><div class="line">        selector = Selector.open();</div><div class="line">        socketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">        byteBuffer = ByteBuffer.allocateDirect(size);</div><div class="line">        byteBuffer.order(ByteOrder.BIG_ENDIAN);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void listener() throws Exception &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            int n = selector.select();</div><div class="line">            if (n == 0) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            Iterator&lt;SelectionKey&gt; ite = selector.selectedKeys().iterator();</div><div class="line">            while (ite.hasNext()) &#123;</div><div class="line">                SelectionKey key = ite.next();</div><div class="line">                //a connection was accepted by a ServerSocketChannel.</div><div class="line">                if (key.isAcceptable()) &#123;</div><div class="line">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</div><div class="line">                    SocketChannel channel = server.accept();</div><div class="line">                    registerChannel(selector, channel, SelectionKey.OP_READ);</div><div class="line">                    remoteClientNum++;</div><div class="line">                    System.out.println(&quot;online client num=&quot;+remoteClientNum);</div><div class="line">                    replyClient(channel);</div><div class="line">                &#125;</div><div class="line">                //a channel is ready for reading</div><div class="line">                if (key.isReadable()) &#123;</div><div class="line">                    readDataFromSocket(key);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ite.remove();//must</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void readDataFromSocket(SelectionKey key) throws Exception &#123;</div><div class="line">        SocketChannel socketChannel = (SocketChannel) key.channel();</div><div class="line">        int count;</div><div class="line">        byteBuffer.clear();</div><div class="line">        while ((count = socketChannel.read(byteBuffer)) &gt; 0) &#123;</div><div class="line">            byteBuffer.flip(); // Make buffer readable</div><div class="line">            // Send the data; don&apos;t assume it goes all at once</div><div class="line">            while (byteBuffer.hasRemaining()) &#123;</div><div class="line">                socketChannel.write(byteBuffer);</div><div class="line">            &#125;</div><div class="line">            byteBuffer.clear(); // Empty buffer</div><div class="line">        &#125;</div><div class="line">        if (count &lt; 0) &#123;</div><div class="line">            socketChannel.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void replyClient(SocketChannel channel) throws IOException &#123;</div><div class="line">        byteBuffer.clear();</div><div class="line">        byteBuffer.put(&quot;hello client!\r\n&quot;.getBytes());</div><div class="line">        byteBuffer.flip();</div><div class="line">        channel.write(byteBuffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void registerChannel(Selector selector, SocketChannel channel, int ops) throws Exception &#123;</div><div class="line">        if (channel == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        channel.configureBlocking(false);</div><div class="line">        channel.register(selector, ops);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            new ServerSocketChannelTest().listener();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>Client Terminal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class SocketChannelTest &#123;</div><div class="line"></div><div class="line">    private int size = 1024;</div><div class="line">    private ByteBuffer byteBuffer;</div><div class="line">    private SocketChannel socketChannel;</div><div class="line"></div><div class="line">    public void connectServer() throws IOException &#123;</div><div class="line">        socketChannel = SocketChannel.open();</div><div class="line">        socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 8998));</div><div class="line">        byteBuffer = ByteBuffer.allocate(size);</div><div class="line">        byteBuffer.order(ByteOrder.BIG_ENDIAN);</div><div class="line">        receive();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void receive() throws IOException &#123;</div><div class="line">        while (true) &#123;</div><div class="line">            int count;</div><div class="line">            byteBuffer.clear();</div><div class="line">            while ((count = socketChannel.read(byteBuffer)) &gt; 0) &#123;</div><div class="line">                byteBuffer.flip();</div><div class="line">                while (byteBuffer.hasRemaining()) &#123;</div><div class="line">                    System.out.print((char) byteBuffer.get());</div><div class="line">                &#125;</div><div class="line">                //send(&quot;send data to server\r\n&quot;.getBytes());</div><div class="line">                byteBuffer.clear();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void send(byte[] data) throws IOException &#123;</div><div class="line">        byteBuffer.clear();</div><div class="line">        byteBuffer.put(data);</div><div class="line">        byteBuffer.flip();</div><div class="line">        socketChannel.write(byteBuffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        new SocketChannelTest().connectServer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/07/30/Java学习-Nio-Selector/" data-id="cjkthb97x000aln1btktxtm2y" class="article-share-link">分享</a><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a href="/2017/07/31/Elasticsearch基础/" class="pre">Elasticsearch基础</a><a href="/2017/07/23/Hero-git搭建blog/" class="next">Hexo搭建blog</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/flume/" style="font-size: 15px;">flume</a> <a href="/tags/es/" style="font-size: 15px;">es</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/Java日志体系/">Java日志体系</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/maven详解/">maven详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/Flume源码-组件内部结构/">Flume源码-组件内部结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/18/Linux-oom-killer详解及应用/">Linux-oom killer详解及应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/13/Linux-cgroup/">Linux-cgroup隔离cpu资源</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/12/Flume源码-工作流程/">Flume源码-工作流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Java学习-ThreadLocal/">Java学习-ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/Elasticsearch基础/">Elasticsearch基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/Java学习-Nio-Selector/">Java学习-Nio Selector</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/23/Hero-git搭建blog/">Hexo搭建blog</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://cherry1084.giyhub.io/" title="爱小晴个人博客未来站点" target="_blank">爱小晴个人博客未来站点</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">JunDa Chen's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>