<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>maven详解 | JunDa Chen's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">maven详解</h1><a id="logo" href="/.">JunDa Chen's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">maven详解</h1><div class="post-meta">Jul 26, 2018<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#maven生命周期"><span class="toc-number">2.</span> <span class="toc-text">maven生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期介绍"><span class="toc-number">2.1.</span> <span class="toc-text">生命周期介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行调用"><span class="toc-number">2.2.</span> <span class="toc-text">命令行调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#maven-plugins"><span class="toc-number">3.</span> <span class="toc-text">maven plugins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置maven"><span class="toc-number">4.</span> <span class="toc-text">配置maven</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#maven依赖管理"><span class="toc-number">5.</span> <span class="toc-text">maven依赖管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引入依赖"><span class="toc-number">5.1.</span> <span class="toc-text">引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包冲突"><span class="toc-number">5.2.</span> <span class="toc-text">包冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖最佳实践"><span class="toc-number">5.3.</span> <span class="toc-text">依赖最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖范围"><span class="toc-number">5.4.</span> <span class="toc-text">依赖范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用的maven插件"><span class="toc-number">6.</span> <span class="toc-text">常用的maven插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建自定义maven插件"><span class="toc-number">7.</span> <span class="toc-text">创建自定义maven插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Why？"><span class="toc-number">7.1.</span> <span class="toc-text">Why？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How"><span class="toc-number">7.2.</span> <span class="toc-text">How</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行自定义plugin"><span class="toc-number">7.3.</span> <span class="toc-text">运行自定义plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数"><span class="toc-number">7.4.</span> <span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mojo参数"><span class="toc-number">7.4.1.</span> <span class="toc-text">Mojo参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义参数"><span class="toc-number">7.4.2.</span> <span class="toc-text">自定义参数</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>maven是现在最流行的依赖管理工具，本文将从什么是maven，maven的生命周期是什么，如何调用maven，maven如何配置使用，maven如何管理依赖，依赖冲突和解决，如何创建自定义maven插件这几个问题入手来介绍maven。</p>
<h2 id="maven生命周期"><a href="#maven生命周期" class="headerlink" title="maven生命周期"></a>maven生命周期</h2><h3 id="生命周期介绍"><a href="#生命周期介绍" class="headerlink" title="生命周期介绍"></a>生命周期介绍</h3><p>maven定义了三套生命周期：<code>clean</code>,<code>default</code>,<code>site</code>。三套生命周期相互独立，每个生命周期都包含了一些阶段(phase)，且这些phase是有序的，后面的phase依赖于前一个phase。各生命周期的具体phase可见官网：<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank" rel="external">maven生命周期细分</a><br>其中最核心的default生命周期大致可以分为以下几个phase。<br><img src="/img/maven_default_phase.jpg" alt="default lifecycle"><br>上图中每个phase的作用：<br><img src="/img/maven_default_phase_function.jpg" alt="default lifecycle phase"></p>
<h3 id="命令行调用"><a href="#命令行调用" class="headerlink" title="命令行调用"></a>命令行调用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mvn complie</div><div class="line">$ mvn package</div><div class="line">$ mvn install</div></pre></td></tr></table></figure>
<p>maven支持执行到指定的某个phase，如mvn compile，mvn package，mvn install,在执行某个phase的命令之前，会把按顺序把该phase前的各phase都执行完一遍；如mvn compile只执行validate、complie两个phase之后退出；mvn package执行validate、compile、test、package；mvn install将执行validate、compile、test、package、verify、install，并将package生成的包发布到本地<br>仓库中。其中某些带有连字符的阶段不能通过shell命令单独指定。例如：(pre-, post-, or process-*)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn clean package</div></pre></td></tr></table></figure>
<p>maven支持在一条命令中构建不同生命周期的阶段，上述命令会首先完成clean lifecycle,然后执行default lifecycle到package phase。</p>
<h2 id="maven-plugins"><a href="#maven-plugins" class="headerlink" title="maven plugins"></a>maven plugins</h2><p>maven是依赖各插件(plugins)来完成生命周期的运行。生命周期的每个phase都依赖插件提供的目标(goal)来实现，每个插件至少含有1到n个goal,用户可以绑定goal到某个phase，例如compiler插件提供了两个goal：compile和testCompile，分别用来执行源码编译和测试代码编译；<br>phase和goal的关系是多对多的，一个phase可以对应多个goal(即多个plugin的goal可以绑定到同一个phase上)，一个goal可以对应多个phase，在配置文件中可以自定义。<br>当然也可以自定插件自定义目标，再自定义目标在某个phase前后执行。plugin和goal的设定给maven管理依赖提供了很大的便利。<br>phase和goal的绑定关系如下图所示：<br><img src="/img/maven_phase_goal_relation.jpg" alt="插件绑定到生命周期"></p>
<h2 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h2><p>在pom文件中，打包类型支持多种：jar、war、ear、pom等，在没有任何自定义的情况下，不同packaging类型会默认绑定不同的plugin，下面是当packaging类型为jar时，phase和plugin, goal的绑定关系。<br><img src="/img/maven_jar_bind.jpg" alt="jar_bind"></p>
<p>在pom.xml文件中，<build> <plugins>元素下可以添加<plugin>，通过指定goal和phase来进行绑定。例如将maven-source-plugin的jar-no-fork目标绑定到default生命周期的package阶段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">    &lt;plugins&gt;</div><div class="line">        &lt;plugin&gt;</div><div class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;2.2.1&lt;/version&gt;</div><div class="line">            &lt;executions&gt;</div><div class="line">                &lt;execution&gt;</div><div class="line">                    &lt;id&gt;attach-source&lt;/id&gt;</div><div class="line">                    &lt;phase&gt;package&lt;/phase&gt;&lt;!-- 要绑定到的生命周期的阶段 --&gt;</div><div class="line">                    &lt;goals&gt;</div><div class="line">                        &lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;!-- 要绑定的插件的目标 --&gt;</div><div class="line">                    &lt;/goals&gt;</div><div class="line">                &lt;/execution&gt;</div><div class="line">            &lt;/executions&gt;</div><div class="line">        &lt;/plugin&gt;</div><div class="line">    &lt;/plugins&gt;</div><div class="line">    ……</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure></plugin></plugins></build></p>
<p>插件同时还支持高度扩展，能后自定义参数，完成需求，如配置maven-compiler-plugin插件编译源代码的JDK版本为1.7：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</div><div class="line">    &lt;configuration&gt;</div><div class="line">        &lt;source&gt;1.7&lt;/source&gt;</div><div class="line">        &lt;target&gt;1.7&lt;/target&gt;</div><div class="line">    &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p>
<p><code>&lt;configuration&gt;</code>标签用于向Mojo中传递参数</p>
<h2 id="maven依赖管理"><a href="#maven依赖管理" class="headerlink" title="maven依赖管理"></a>maven依赖管理</h2><p>管理依赖是maven的核心功能之一。下面将讲解maven是如何引入依赖，包冲突是怎么产生的，maven解决包冲突，什么是依赖范围，包依赖的最佳实践。</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在代码开发时，如果需要使用第三方jar包提供的类库，那么需要在pom.xml加入该jar包依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.5.2&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>通过依赖传递的方式引入jar包，在pom.xml中引入httpclient jar包依赖，当maven解析该依赖时，需要引入的jar包不仅仅只有httpclient，还会有内部依赖的jar包，还会有httpclient内部依赖的jar包依赖的jar包，形成一个树形结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ *** ---</div><div class="line">[INFO] ***.********.***:***:jar:1.2.4</div><div class="line">[INFO] +- org.apache.httpcomponents:httpclient:jar:4.5.2:compile</div><div class="line">[INFO] |  +- org.apache.httpcomponents:httpcore:jar:4.4.4:compile</div><div class="line">[INFO] |  +- commons-logging:commons-logging:jar:1.2:compile</div><div class="line">[INFO] |  \- commons-codec:commons-codec:jar:1.9:compile</div><div class="line">[INFO] +- org.slf4j:slf4j-api:jar:1.7.2:compile</div><div class="line">....</div></pre></td></tr></table></figure></p>
<p>如上，实际引入的jar有httpcore、commons-logging、commons-codec和httpclient。</p>
<h3 id="包冲突"><a href="#包冲突" class="headerlink" title="包冲突"></a>包冲突</h3><p>For example:假设 A-&gt;B-&gt;C-&gt;D1, E-&gt;F-&gt;D2，D1,D2 分别为 D 的不同版本。<br>如果 pom.xml 文件中引入了 A 和 E 之后，按照 maven 传递依赖原则，工程内需要引入的实际 Jar 包将会有：A B C D1 和 E F D2，因此 D1,D2 将会产生包冲突。<br>maven解析 pom.xml 文件时，同一个 jar 包只会保留一个，这样有效的避免因引入两个 jar 包导致的工程运行不稳定性。</p>
<p>maven的默认处理策略有两个：最短路径优先和最先声明优先</p>
<ol>
<li>最短路径优先<br>maven 面对 D1 和 D2 时，会默认选择最短路径的那个 jar 包，即 D2。E-&gt;F-&gt;D2 比 A-&gt;B-&gt;C-&gt;D1 路径短 1。</li>
<li>最先声明优先<br>如果路径一样的话，举个例子： A-&gt;B-&gt;C1, E-&gt;F-&gt;C2 ，两个依赖路径长度都是 2，那么就选择最先声明。</li>
</ol>
<h3 id="依赖最佳实践"><a href="#依赖最佳实践" class="headerlink" title="依赖最佳实践"></a>依赖最佳实践</h3><p>maven默认的处理策略可能导致最终引入的包不是我们期望的，常见的是maven引用了低版本的某个依赖，忽略高版本的依赖，从而导致代码中报错：NoSuchMethodEx。可以使用包冲突检测工具：<a href="http://maven.apache.org/plugins/maven-dependency-plugin/plugin-info.html" target="_blank" rel="external">mvn dependency:tree</a> 或者 IDEA plugin：Maven Helper，找出冲突依赖，自定义exclude。<br>exclude实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.7.2&lt;/version&gt;</div><div class="line">        &lt;exclusions&gt;</div><div class="line">            &lt;exclusion&gt;</div><div class="line">                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">            &lt;/exclusion&gt;</div><div class="line">        &lt;/exclusions&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>如果不显示执行 <scope> 属性时，默认 <scope>compile</scope>。<br>scope 有哪些属性：compile, provided, runtime, test, system 等。详细参考：<a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope" target="_blank" rel="external">依赖范围</a></scope></p>
<h2 id="常用的maven插件"><a href="#常用的maven插件" class="headerlink" title="常用的maven插件"></a>常用的maven插件</h2><p><a href="https://www.jianshu.com/p/7a0e20b30401" target="_blank" rel="external">maven-shade-plugin入门指南</a><br><a href="https://www.jianshu.com/p/14bcb17b99e0" target="_blank" rel="external">maven-assembly-plugin入门指南</a></p>
<h2 id="创建自定义maven插件"><a href="#创建自定义maven插件" class="headerlink" title="创建自定义maven插件"></a>创建自定义maven插件</h2><h3 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h3><p>上文提及包依赖冲突的解决方法是上线之后事后发现，会影响线上生产，如何把包依赖冲突发现提前，在上线之前发现解决？这里可以自定义一个maven plugin，自定义一个检测依赖的goal，将其绑定到compile之后执行，如果无冲突编译通过，有包冲突则构建失败。<br>当然这只是其中一个应用场景，还有其他的需求可以自定义plugin解决。<br>关于如何自定义plugin，在官网上有很详细地说明，<a href="http://maven.apache.org/guides/plugin/guide-java-plugin-development.html" target="_blank" rel="external">详细链接</a>,这里只是对官网进行翻译和实践~</p>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>解释一下一个名词<code>MOJO</code> (Maven plain Old Java Object),每一个 Mojo 就是 Maven 中的一个执行目标（executable goal），而插件则是对单个或多个相关的 Mojo 做统一分发。一个 Mojo 包含一个简单的 Java 类。插件中多个类似 Mojo 的通用之处可以使用抽象父类来封装。<br>自定义插件需要手动添加一个依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;3.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>与普通 pom.xml 文件一个重要的不同之处是它的打包方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;packaging&gt;maven-plugin&lt;/packaging&gt;</div></pre></td></tr></table></figure></p>
<p>先上一个简单的demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package sample.plugin;</div><div class="line"></div><div class="line">import org.apache.maven.plugin.AbstractMojo;</div><div class="line">import org.apache.maven.plugin.MojoExecutionException;</div><div class="line">import org.apache.maven.plugins.annotations.Mojo;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Says &quot;Hi&quot; to the user.</div><div class="line"> *</div><div class="line"> */</div><div class="line">@Mojo( name = &quot;sayhi&quot;)</div><div class="line">public class GreetingMojo extends AbstractMojo</div><div class="line">&#123;</div><div class="line">    public void execute() throws MojoExecutionException</div><div class="line">    &#123;</div><div class="line">        getLog().info( &quot;Hello, world.&quot; );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>抽象类<code>org.apache.maven.plugin.abstractmojo</code>提供了必须的实现，重写<code>execute</code>方法即可</li>
<li>注释<code>@Mojo</code>是必须的，相当于goal，它控制when和how to执行这个Mojo</li>
<li><code>execute</code>方法会抛出两个异常，<code>org.apache.maven.plugin.MojoExecutionException</code>和<code>org.apache.maven.plugin.MojoFailureException</code>,前者在构建失败时抛出BUILD ERROR，后者抛出BUILD FAILURE</li>
<li>方法<code>getLog</code>在AbstractMojo中定义，会返回一个log4j-*的logger对象，可以使用这个对象写出不同level的日志，<code>debug</code>,<code>info</code>,<code>warn</code>,<code>error</code>,这个方法会返回内容到console</li>
<li>要使用@Mojo 注释，需要额外引入一个新的依赖。org.apache.maven.plugin-tools:maven-plugin-annotations:jar:3.1;当然不使用@Mojo的话，也可以在类注释中使用<code>@goal goalName</code>来声明这是一个mojo</li>
</ol>
<h3 id="运行自定义plugin"><a href="#运行自定义plugin" class="headerlink" title="运行自定义plugin"></a>运行自定义plugin</h3><p>与其他plugin类似，我们需要在pom.xml中引用该plugin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">    &lt;plugins&gt;</div><div class="line">        &lt;plugin&gt;</div><div class="line">            &lt;groupId&gt;com.xxx&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;xxx-maven-plugin&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">        &lt;/plugin&gt;</div><div class="line">    &lt;/plugins&gt;</div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure></p>
<p>执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn groupId:artifactId(xxx-maven-plugin):version(1.0-SNAPSHOT):goalName(hello)</div></pre></td></tr></table></figure></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="Mojo参数"><a href="#Mojo参数" class="headerlink" title="Mojo参数"></a>Mojo参数</h4><p>上述运行太费劲了，如果作为服务提供方，需要强制用户去记住插件的groupId,artifactId,version和goal。最好是能够融入mvn compile,mvn package,mvn install等常用命令之中自动执行，这才是最理想的。<br>注释 @Mojo 含有defaultPhase，requiresDependencyResolution等参数。</p>
<ol>
<li>goal<name>,唯一必须声明的标注，当用户命令行调用或在pom中配置插件是，需使用该目标名称</name></li>
<li>phase <phase>:默认将该目标绑定至default声明周期的某个阶段，这样在配置使用插件目标时，就无需声明phase，如maven-surefire-plugin的test目标带有@phase tes标注</phase></li>
<li>requiresDependencyResolution <scope>:在运行mojo之前必须解析所有指定范围的依赖，见上文的依赖范围，如maven-surefire-plugin的test目标带有requiresDependencyResolution test标注，表示执行测试前，所有测试范围的依赖必须得到解析</scope></li>
<li>requiresProject <true false="">:该目标是否必须在一个maven项目中运行（如测试插件用于测试其他项目），默认为true。大部分插件目标需依赖一个项目才能运行，但是，maven-help-plugin的system目标例外，它用来显示系统属性和环境变量信息，无需实际项目。</true></li>
<li>requiresOnline <true false="">:是否要求maven必须是在线状态，默认值为false</true></li>
<li>requiresReport <true false="">:是否要求项目报告已经生成，默认为false</true></li>
<li>aggregator:当mojo在多模块项目上运行时，该标注表示目标只会在顶层模块运行。</li>
<li>requiresDirectInvocation <true false="">:为true时，该目标就只能通过命令行直接调用。默认为false</true></li>
<li>execute goal=”<goal>“:在运行该目标之前，让maven运行另外一个目标。如果是本插件目标，则直接调用目标名称，否则，使用“prefix:goal”</goal></li>
<li>execute phase=”<phase>“:在运行该目标前，让maven先运行一个并行的生命周期，到指定的阶段为止。到phase执行完，才执行插件目标</phase></li>
<li>execute lifecycle=”<lifecycle>“ phase = “<phase>“:在运行该目标前，让maven先运行一个自定义的生命周期，到指定的阶段为止。</phase></lifecycle></li>
</ol>
<p>回到开头的问题，配置pom文件，当输入mvn phase时，自动运行自定义插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// Mojo类中的配置</div><div class="line">@Mojo(name = &quot;checkPom&quot;, defaultPhase = LifecyclePhase.COMPILE, requiresDependencyResolution = ResolutionScope.COMPILE)</div><div class="line">public class ScribeLogCheckMojo extends AbstractMojo&#123;</div><div class="line">    @Override</div><div class="line">    public void execute() throws MojoExecutionException, MojoFailureException &#123;</div><div class="line">        // code here</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体项目中的pom配置</div><div class="line">&lt;build&gt;</div><div class="line">    &lt;plugins&gt;</div><div class="line">        ...    </div><div class="line">        &lt;plugin&gt;</div><div class="line">            &lt;groupId&gt;com.meituan.log&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;scribelog4j2-maven-plugin&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;1.0.1&lt;/version&gt;</div><div class="line">            &lt;executions&gt;</div><div class="line">                &lt;execution&gt;</div><div class="line">                    &lt;goals&gt;</div><div class="line">                        &lt;goal&gt;checkPom&lt;/goal&gt;</div><div class="line">                    &lt;/goals&gt;</div><div class="line">                    &lt;phase&gt;compile&lt;/phase&gt;</div><div class="line">                &lt;/execution&gt;</div><div class="line">            &lt;/executions&gt;</div><div class="line">        &lt;/plugin&gt;</div><div class="line">    &lt;/plugins&gt;</div><div class="line">&lt;/build&gt;</div><div class="line"></div><div class="line">// maven命令</div><div class="line">mvn complie/ phase&gt;compile</div></pre></td></tr></table></figure></p>
<h4 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h4><p>使用@parameter将mojo的某个字段标注为可配置参数，支持boolean,int,float,String,Date,File,Url,数组,Collection,map,Propertes。详情请见：<a href="http://maven.apache.org/guides/plugin/guide-java-plugin-development.html#" target="_blank" rel="external">Maven @Parameters</a>，官方文档已经描述得很全面了，这里不再赘述。</p>
<p>值得一提的是，maven提供了一些很实用的内置属性（${} properties）<br>目录属性</p>
<ol>
<li>${basedir}表示项目根目录，即包含pom.xml文件的目录;${version}表示项目版本;${project}表示一个pom的<project></project></li>
</ol>
<p>pom属性：</p>
<ol>
<li>pom属性，${project.build.sourceDirectory}:项目的主源码目录，默认为src/main/java/.</li>
<li>${project.build.testSourceDirectory}:项目的测试源码目录，默认为/src/test/java/.</li>
<li>${project.build.directory}:项目构建输出目录，默认为target/. </li>
<li>${project.build.outputDirectory}:项目主代码编译输出目录，默认为target/classes/. </li>
<li>${project.build.testOutputDirectory}:项目测试代码编译输出目录，默认为target/testclasses/. </li>
<li>${project.groupId},${project.artifactId},${project.version},${project.build.finalName}</li>
</ol>
<p>Settings属性：与POM属性同理。如${settings.localRepository}指向用户本地仓库的地址。<br>Java系统属性：所有Java系统属性都可以使用Maven属性引用，例如${user.home}指向了用户目录。可以通过命令行mvn help:system查看所有的Java系统属性<br>环境变量属性：所有环境变量都可以使用以env.开头的Maven属性引用。例如${env.JAVA_HOME}指代了JAVA_HOME环境变量的值。也可以通过命令行mvn help:system查看所有环境变量。</p>
<hr>
<p>参考链接</p>
<ol>
<li><a href="http://maven.apache.org/index.html" target="_blank" rel="external">Maven官网</a></li>
<li><a href="https://blog.csdn.net/z69183787/article/details/52984622" target="_blank" rel="external">mojo标注和参数</a></li>
<li><a href="https://www.jianshu.com/p/7a0e20b30401" target="_blank" rel="external">maven-shade_plugin使用指南</a></li>
<li><a href="https://www.jianshu.com/p/14bcb17b99e0" target="_blank" rel="external">maven-assembly-plugin入门指南</a></li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2018/07/26/maven详解/" data-id="ck0rmzm0h000vmo1b54xwe5fl" class="article-share-link">分享</a><div class="tags"><a href="/tags/工具/">工具</a></div><div class="post-nav"><a href="/2018/08/13/Java日志体系/" class="pre">Java日志体系</a><a href="/2017/08/19/Flume源码-组件内部结构/" class="next">Flume源码-组件内部结构</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/事务/">事务</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/flume/" style="font-size: 15px;">flume</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/莆田家事/" style="font-size: 15px;">莆田家事</a> <a href="/tags/es/" style="font-size: 15px;">es</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/20/征迁小总结/">征迁小总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/Java日志体系/">Java日志体系</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/maven详解/">maven详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/Flume源码-组件内部结构/">Flume源码-组件内部结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/18/Linux-oom-killer详解及应用/">Linux-oom killer详解及应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/13/Linux-cgroup/">Linux-cgroup隔离cpu资源</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/12/Flume源码-工作流程/">Flume源码-工作流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Java学习-ThreadLocal/">Java学习-ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/Elasticsearch基础/">Elasticsearch基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/Java学习-Nio-Selector/">Java学习-Nio Selector</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://cherry1084.giyhub.io/" title="爱小晴个人博客未来站点" target="_blank">爱小晴个人博客未来站点</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">JunDa Chen's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>