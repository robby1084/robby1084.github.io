<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java日志体系 | JunDa Chen's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java日志体系</h1><a id="logo" href="/.">JunDa Chen's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java日志体系</h1><div class="post-meta">Aug 13, 2018<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java日志框架发展史"><span class="toc-number">1.</span> <span class="toc-text">Java日志框架发展史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#功能实现"><span class="toc-number">1.1.</span> <span class="toc-text">功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Log4j"><span class="toc-number">1.1.1.</span> <span class="toc-text">Log4j</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JUL-Java-Util-Logging"><span class="toc-number">1.1.2.</span> <span class="toc-text">JUL (Java Util Logging)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#统一入口-Facade门面"><span class="toc-number">1.2.</span> <span class="toc-text">统一入口-Facade门面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JCL-Java-Commons-Logging"><span class="toc-number">1.2.1.</span> <span class="toc-text">JCL(Java Commons Logging)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLF4J"><span class="toc-number">1.2.2.</span> <span class="toc-text">SLF4J</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#追求性能"><span class="toc-number">1.3.</span> <span class="toc-text">追求性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#logback"><span class="toc-number">1.3.1.</span> <span class="toc-text">logback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Log4j2"><span class="toc-number">1.3.2.</span> <span class="toc-text">Log4j2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日志框架发展史"><span class="toc-number">1.4.</span> <span class="toc-text">日志框架发展史</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Log学习"><span class="toc-number">2.</span> <span class="toc-text">Log学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SLF4J-1"><span class="toc-number">2.1.</span> <span class="toc-text">SLF4J</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log4j2-1"><span class="toc-number">2.2.</span> <span class="toc-text">Log4j2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#上下文环境"><span class="toc-number">2.2.1.</span> <span class="toc-text">上下文环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置文件"><span class="toc-number">2.2.2.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Logger-amp-LoggerConfig"><span class="toc-number">2.2.3.</span> <span class="toc-text">Logger & LoggerConfig</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Appender-amp-Layout"><span class="toc-number">2.2.4.</span> <span class="toc-text">Appender & Layout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Filter"><span class="toc-number">2.2.5.</span> <span class="toc-text">Filter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Plugin"><span class="toc-number">2.3.</span> <span class="toc-text">Plugin</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="Java日志框架发展史"><a href="#Java日志框架发展史" class="headerlink" title="Java日志框架发展史"></a>Java日志框架发展史</h2><p>使用Java打日志，在谷歌上随便一搜，会找出好多种解决方案，log4j?jcl?jul?logback?slf4j?log4j2?这些都是什么？有什么区别呢？我应该选哪种合适？本文将梳理一下日志框架的发展史，讲清楚这些框架的历史发展过程；最后会附上日志的使用和日志自定义。</p>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>一门语言的产生使用是离不开日志输出的，服务监控、报警、报表、分析都离不开日志。</p>
<h4 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h4><p>Java在最开始的时候是没有打日志功能的。Apache最开始开源了Log4j，是应用最广泛的日志工具，已经成为Java日志实际上的标准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import org.apache.log4j.Logger;</div></pre></td></tr></table></figure>
<h4 id="JUL-Java-Util-Logging"><a href="#JUL-Java-Util-Logging" class="headerlink" title="JUL (Java Util Logging)"></a>JUL (Java Util Logging)</h4><p>日志的实现的市场被开源社区占据，作为Java官方的Sun公司肯定不服气啊，打日志作为Java的基础功能，在jdk1.4中开始支持了log，这就是JUL(Java Util Logging)，目标很明显，就是针对Log4j,两者开始争夺Java功能实现的市场。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import java.util.logging.Logger;</div></pre></td></tr></table></figure>
<h3 id="统一入口-Facade门面"><a href="#统一入口-Facade门面" class="headerlink" title="统一入口-Facade门面"></a>统一入口-Facade门面</h3><p>再后来市场争夺从功能实现转到了日志门面类。那么什么是门面类呢？比如有一个项目中，含有多个模块，一个模块使用log4j来实现打日志功能，另一个模块使用JUL来实现打日志功能,…(打日志的功能实现市场不只是上述两家)，随着引入的开源组件越来越多，自己项目中的模块越来越多，难免地日志的实现配置也会越来越多，这就会引起混乱了，在找日志的时候，不同的模块需要去不同的配置的路径下找日志，这是很不合理的事情。为了解决这个痛点，日志门面就诞生了，Facade统一了日志实现的接口，屏蔽了底层实现。项目中只要引用同一个日志门面，无论底层用哪一种功能实现，日志门面都能平滑地支持和转换。<br>其实门面类最开始的设计是固定实现的，由门面类来决定要使用哪一种实现，由门面类的一个文件去指定；这显然不够灵活，大量的配置很繁琐。门面类后来发展增加了日志绑定包，支持了各种底层实现的api，使用各种facade-to-log4j,facade-to-jul来链接各种底层实现。要使用哪种底层实现，只要引用对应的日志绑定包就可以了，彻底抛弃了文件配置绑定。</p>
<p><img src="/img/log_facade.jpg" alt="Logging Facade"></p>
<h4 id="JCL-Java-Commons-Logging"><a href="#JCL-Java-Commons-Logging" class="headerlink" title="JCL(Java Commons Logging)"></a>JCL(Java Commons Logging)</h4><p>最开始提出日志门面类这一设计的，没错，又是Apache！既然日志实现类那么多，那你们就去争吧，我只要统一了日志门面类，把入口给统一了，用户就认识我，底层默认要用什么实现也都是我说了算。日志门面类这种东西在项目中肯定只有一个，但是日志实现类可以有多个。由于就有了JCL(Java Commons Loging)，Spring最开始就是使用JCL来打日志的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import org.apache.commons.logging.Log;</div><div class="line">import org.apache.commons.logging.LogFactory;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    private static final Log log = LogFactory.getLog(Main.class);</div><div class="line">    public static void main()&#123;</div><div class="line">        log.info(&quot;Hello World!&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h4><p>slf4j的作者是从Apache基金会出来的，他觉得JCL实现的接口不好用，重新搞了一套门面类slf4j，现在市场上日志门面类的争夺主要就是JCL和slf4j。哦，对了。顺带一提，slf4j的作者叫做Ceki Gülcü，也被业界誉为Java日志之父。包括后续的改进底层实现性能的几款产品都是出自他之手。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LogFactory;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    private static final Logger logger = LoggerFactory.getLogger(Main.class);</div><div class="line">    public static void main()&#123;</div><div class="line">        logger.info(&quot;Hello World!&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="追求性能"><a href="#追求性能" class="headerlink" title="追求性能"></a>追求性能</h3><h4 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h4><p>Ceki Gülcü在搞完slf4j之后，为了给slf4j设计一款默认底层实现(亲儿子)，虽然有很多的日志实现，但是默认(推荐)的日志绑定包是我自己的，也就是logback。作为默认推荐的实现，logback的卖点就是性能，logback的性能也比前几代都要高出好几倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import ch.qos.logback.classic.Logger;</div><div class="line">import org.slf4j.LogFactory;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    private static final Logger logger = LoggerFactory.getLogger(Main.class);</div><div class="line">    public static void main()&#123;</div><div class="line">        logger.info(&quot;Hello World!&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h4><p>值得一提的是，Ceki Gülcü也参与了前文提到的log4j项目。在完成了logback之后发现，第一个抢占市场的log4j的用户粘性很大，logback抢占不了多少市场。既然log4j那么流行，就不能放弃log4j，于是搞出来了log4j2.但是其实log4j2和log4j完全是两码事，日志绑定包api完全不兼容，只是挂了一个名而已。为了抢占市场，偷换概念其实是一个很棒的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import org.apache.logging.log4j.LogManager;</div><div class="line">import org.apache.logging.log4j.Logger;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    private static final Logger logger = LogManager.getLogger(Main.class);</div><div class="line">    public static void main()&#123;</div><div class="line">        logger.info(&quot;Hello World!&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="日志框架发展史"><a href="#日志框架发展史" class="headerlink" title="日志框架发展史"></a>日志框架发展史</h3><p>日志框架发展到现在像是一个三国鼎立的状态。三国分别是Apache，Sun和日志之父Ceki Gülcü。Apache率先开源的实现log4j和门面JCL，其中log4j还具有一定影响力；Sun公司的JUL基本上已经灭绝；Ceki Gülcü从Apache的log4j项目出走后搞出了一堆，slf4j,logback,log4j2.是现在的市场领跑者。<br>![日志框架发展(/img/log_frame.jpg)</p>
<p>从GitHub上引用的Java最受欢迎的Top 20 Libraries截图如下：<br><img src="/img/java_logging_used_sort.jpg" alt="The Top20 Libraries Used By GitHub Most Popular Java Projects"></p>
<p>可以看出，截止到2018-08-14，日志接口类中slf4j是目前的胜者，jcl则混得有点差；日志实现类中log4j还是老大哥(名字取得好啊，一目了然，一看就知道是做什么的,虽然log4j在2015年的时候Apache官网已经宣布停止更新了，final version=1.2.17)，jul几乎无人问津，logback和log4j2则是新秀。</p>
<h2 id="Log学习"><a href="#Log学习" class="headerlink" title="Log学习"></a>Log学习</h2><p>我们这里重点介绍SLF4J+Log4j2+Log4j2 Plugin,在本章中介绍SLF4J和log4j2的使用；在日志自定义中介绍log4j2 plugin</p>
<h3 id="SLF4J-1"><a href="#SLF4J-1" class="headerlink" title="SLF4J"></a>SLF4J</h3><p>前文已经提及了，slf4j是一个接口类，详细介绍可见<a href="https://www.slf4j.org/index.html" target="_blank" rel="external">官网</a>,通过日志绑定包和具体日志实现类绑定再决定使用哪种实现。绑定的过程截取自官网的截图如下：<br><img src="/img/slf4j_bind.jpg" alt="slf4j-bing"></p>
<p>slf4j只是一个接口类，并没有对日志的具体实现，slf4j只做了两件事。提供日志接口和提供具体日志对象的方法；</p>
<ol>
<li>提供日志接口</li>
<li>提供具体日志对象的方法</li>
</ol>
<p>提供日志接口，slf4j万年不变的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LogFactory;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    private static final Logger logger = LoggerFactory.getLogger(Main.class);</div><div class="line">    public static void main()&#123;</div><div class="line">        logger.info(&quot;Hello World!&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于提供具体日志对象的方法，是通过日志绑定包来实现的。<br>当项目中没有引用任何日志实现类时，logger.info的最终去向是/dev/null;当引入了某一个实现，则引用该实现；当引用多个实现时，会根据Java的类加载的机制，哪个被先加载就优先使用哪个类，Console会输出以下提示：</p>
<p><img src="/img/slf4j_bind_conflict.jpg" alt="slf4j多绑定"></p>
<p>想要了解绑定原理，就需要看代码了。slf4j的接口类为LoggerFactory.getLogger(),我们根据这个一路可以找到bind代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static Set&lt;URL&gt; findPossibleStaticLoggerBinderPathSet() &#123;</div><div class="line">    // use Set instead of list in order to deal with bug #138</div><div class="line">    // LinkedHashSet appropriate here because it preserves insertion order</div><div class="line">    // during iteration</div><div class="line">    Set&lt;URL&gt; staticLoggerBinderPathSet = new LinkedHashSet&lt;URL&gt;();</div><div class="line">    try &#123;</div><div class="line">        ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();</div><div class="line">        Enumeration&lt;URL&gt; paths;</div><div class="line">        if (loggerFactoryClassLoader == null) &#123;</div><div class="line">            paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</div><div class="line">        &#125; else &#123;</div><div class="line">            paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);</div><div class="line">        &#125;</div><div class="line">        while (paths.hasMoreElements()) &#123;</div><div class="line">            URL path = paths.nextElement();</div><div class="line">            staticLoggerBinderPathSet.add(path);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (IOException ioe) &#123;</div><div class="line">        Util.report(&quot;Error getting resources from path&quot;, ioe);</div><div class="line">    &#125;</div><div class="line">    return staticLoggerBinderPathSet;</div></pre></td></tr></table></figure>
<p>getLogger的时候会去classpath下找STATIC_LOGGER_BINDER_PATH，STATIC_LOGGER_BINDER_PATH值为”org/slf4j/impl/StaticLoggerBinder.class”，即所有slf4j的实现，在提供的jar包路径下，一定是有”org/slf4j/impl/StaticLoggerBinder.class”存在的。</p>
<h3 id="Log4j2-1"><a href="#Log4j2-1" class="headerlink" title="Log4j2"></a>Log4j2</h3><p>log4j2的卖点是高性能，插件式编程，支持不同日志组件的API，自动更新配置文件。</p>
<p>高性能这一点，我没有自己测试过，可以见网上的测试结果：<br><img src="/img/log4j2_perf.jpg" alt="log4j2-perf"></p>
<p>上图中可以看出，在多线程情况下，log4j2会有很大的性能优势。蓝色是AsyncLogger；红色是混合使用SyncAppender和AsyncAppender；绿色是AsyncAppender；紫色是log4j1的AsyncAppender；浅蓝色是logback的AsyncAppender<br>这里一一介绍一下这几种Async吧。</p>
<ol>
<li>AsyncLogger底层是用Disruptor(import com.lmax.disruptor.dsl.Disruptor)实现的.高性能的根本原因是数据结构使用环形的RingBuffer，去掉了锁的应用。这个设计其实是借鉴了Linux的Disruptor，感兴趣可以去网上查，这里不再赘叙，也不属于本文的范畴。</li>
<li>特殊状态的AsyncAppender是使用的TransferQueue。它是阻塞队列的其中一个实现，阻塞队列有的特性它都拥有。不同的是TransferQueue是给生产者和消费者加锁。</li>
<li>AsyncAppender旨在解决日志异步发送的问题。日志调用logger.info 之后并不会被同步执行。而是会放在AsyncAppender的一个队列中，AsyncAppender调用appender-ref中的appender列表的append方法往下真正的打日志。这里是下文会介绍的插件式变成。</li>
<li>紫色的log4j1是最早版本的AsyncAppender；淡蓝色的是logback的AsyncAppender</li>
</ol>
<p>插件式编程是指在log4j2中一切皆插件，可以满足很高的自定义需求；支持不同日志组件API，log4j2提供各种api，支持各种不同日志实现转到log4j2；自动更新配置文件，指的是Configuration支持定时重新加载。</p>
<p>log4j2的主要组件包括LoggerContext,Configuration,Logger,Appender,Filter；这些组件的关系如下：<br><img src="/img/log4j_classes.jpg" alt="log4j2 类图"></p>
<p>上图的组件关系，其实可以通过log4j2.xml配置文件就能一目了然，配置文件的目的就是按照上图关系加载对应组件。<br>一个项目可以有多个日志上下文，如多模块的项目。每个日志上下文中有Configuration配置，在Configuration中配置配置Logger、Appender；LoggerConfig用于管理logger之间的层级关系；Filter决定过滤规则。</p>
<h4 id="上下文环境"><a href="#上下文环境" class="headerlink" title="上下文环境"></a>上下文环境</h4><p>log4j2的每条消息是一个logEvent实例，logEventFactory在创建logEvent的时候会加载一个properties配置文件，将配置文件的kv通过setContextData放进logEvent实例中。<br>这里可以通过自定义LogEventFactory来自定义上下文环境。自定义方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 在resource目录下新建log4j2.component.properties文件，key为Log4jLogEventFactory，value为类名</div><div class="line">Log4jLogEventFactory=com.xxx.xxx.xxx.PrivateLogEventFactory</div><div class="line"></div><div class="line">// 自定义的logEventFactory中实现LogEventFactory方法，也可以继承默认LogEventFactory：ReusableLogEventFactory</div><div class="line">public class PrivateLogEventFactory extends ReusableLogEventFactory &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public LogEvent createEvent(String loggerName, Marker marker, String fqcn, Level level, Message data, List&lt;Property&gt; properties, Throwable t) &#123;</div><div class="line"></div><div class="line">        if (properties == null) &#123;</div><div class="line">            properties = new LinkedList&lt;Property&gt;();</div><div class="line">        &#125;</div><div class="line">                </div><div class="line">        properties.add(Property.createProperty(Contants.PARAM_IS_OFFLINE_STATUS, &quot;true&quot;));</div><div class="line">        return super.createEvent(loggerName, marker, fqcn, level, data, properties, t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>Configuration是日志的配置文件。Configuration包含了所有的Appenders、上下文范围内的过滤器、LoggerConfigs以及StrSubstitutor.的引用。一下是一个配置样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;Properties&gt;</div><div class="line">    &lt;Property name=&quot;log.path&quot;&gt;.&lt;/Property&gt;</div><div class="line">&lt;/Properties&gt;</div><div class="line">&lt;Configuration status=&quot;WARN&quot;&gt;</div><div class="line">     &lt;Appenders&gt;</div><div class="line">	&lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;</div><div class="line">	    &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;</div><div class="line">	&lt;/Console&gt;</div><div class="line">    &lt;/Appenders&gt;</div><div class="line">    &lt;Loggers&gt;</div><div class="line">        &lt;Root level=&quot;error&quot;&gt;</div><div class="line">	    &lt;AppenderRef ref=&quot;Console&quot;/&gt;</div><div class="line">        &lt;/Root&gt;</div><div class="line">    &lt;/Loggers&gt;</div><div class="line">&lt;/Configuration&gt;</div></pre></td></tr></table></figure>
<p>Configuration支持自动重加载和日志重定向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!-- 每30秒配置文件会动态加载一次,把日志框架的日志warn级别日志会打印到dest地址 --&gt;</div><div class="line">&lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot; dest=&quot;/data1/log4j2.log&quot;&gt;</div><div class="line">    ... </div><div class="line">&lt;/Configuration&gt;</div></pre></td></tr></table></figure>
<h4 id="Logger-amp-LoggerConfig"><a href="#Logger-amp-LoggerConfig" class="headerlink" title="Logger &amp; LoggerConfig"></a>Logger &amp; LoggerConfig</h4><p>日志的名称，类别。每个Logger都会对应一个loggerConfig。log4j2的LoggerFactory.getLogger()就是获取配置logger的方法。在loggerConfig中定义该logger的级别，绑定多个appender，additivity等配置参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;Configuration status=&quot;debug&quot; strict=&quot;true&quot; name=&quot;XMLConfigTest&quot;&gt;</div><div class="line">    &lt;Loggers&gt;</div><div class="line">	&lt;Logger name=&quot;com.aaa.bbb&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;</div><div class="line">	    &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;</div><div class="line">        &lt;/Logger&gt;</div><div class="line">	&lt;Logger name=&quot;com.aaa&quot; level=“info&quot; additivity=&quot;false&quot;&gt;</div><div class="line">	    &lt;AppenderRef ref=&quot;File&quot;/&gt;</div><div class="line">	&lt;/Logger&gt;</div><div class="line">	&lt;Root level=&quot;trace&quot;&gt;</div><div class="line">	    &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;</div><div class="line">	&lt;/Root&gt;</div><div class="line">    &lt;/Loggers&gt;</div><div class="line">&lt;/Configuration&gt;</div></pre></td></tr></table></figure>
<p>举个例子，当getLogger(com.aaa.bbb)会找到第一个logger；当getLogger(com.aaa.ccc)第一个logger对应不上，会返回第二个logger，因为前半部分都是com.aaa；getLogger(com.xxx.yyy)会返回第三个Root<br>值得一提的是，logger是具有层级结构的。getLogger方法通过name，class等参数从loggerConfig中找到对应logger；当addtivity参数为TRUE时，getLogger()会接着往下查找，直到addticity=false停止接着往下查找。</p>
<h4 id="Appender-amp-Layout"><a href="#Appender-amp-Layout" class="headerlink" title="Appender &amp; Layout"></a>Appender &amp; Layout</h4><p>Appender定义了日志输出规则。Appender在Configuration的<appenders>标签中定义<br>原生的log4j2提供了很多原生的Appender；如ConsoleAppender，FileAppender，RollingFileAppender；当然也可以自定义日志输出规则，只需要继承AbstractAppender即可。</appenders></p>
<p>Layout 定义日志的格式。自定义Layout继承AbstractStringLayout即可。</p>
<p>简要介绍一下一个常用的Appender：RollingFileAppender</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">    &lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;</div><div class="line">	&lt;Appenders&gt;</div><div class="line">	    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;logs/app.log&quot;</div><div class="line">		filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;</div><div class="line">		&lt;PatternLayout&gt;</div><div class="line">		    &lt;Pattern&gt;%d %p %c&#123;1.&#125; [%t] %m%n&lt;/Pattern&gt;</div><div class="line">		&lt;/PatternLayout&gt;</div><div class="line">	        &lt;Policies&gt;</div><div class="line">		    &lt;TimeBasedTriggeringPolicy /&gt;</div><div class="line">		    &lt;SizeBasedTriggeringPolicy size=&quot;250 MB&quot;/&gt;</div><div class="line">		&lt;/Policies&gt;</div><div class="line">            &lt;/RollingFile&gt;</div><div class="line">	&lt;/Appenders&gt;</div><div class="line">	&lt;Loggers&gt;</div><div class="line">	    &lt;Root level=&quot;error&quot;&gt;</div><div class="line">		&lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;</div><div class="line">	    &lt;/Root&gt;</div><div class="line">	&lt;/Loggers&gt;</div><div class="line">    &lt;/Configuration&gt;</div></pre></td></tr></table></figure>
<p>常用的有4个日志文件切分策略：CompositeTriggeringPolicy；OnStartupTriggeringPolicy；SizeBasedTriggeringPolicy；TimeBasedTriggeringPolicy</p>
<ol>
<li>符合策略，使用多个Policy</li>
<li>启动是触发的策略</li>
<li>日志文件达到一定大小即切分文件的策略</li>
<li>时间策略，如每个小时、每天做一次日志文件切分</li>
</ol>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>Filter日志过滤条件，原生提供的Filter有4中，BurstFilter;CompositeFilter;ThresholdFilter;TimeFilter。当然也可以自定义实现。</p>
<ol>
<li>BurstFilter控制打日志的频率；如配置<code>&lt;BurstFilter level=&quot;INFO&quot; rate=&quot;16&quot; maxBurst=&quot;100&quot;&gt;</code>;每秒通过日志16条，maxBurst是一个计数器，当大于16的个数大于100次之后，日志就会被抛弃；</li>
<li>CompositeFilter配置多个Filter</li>
<li>ThresholdFilter是指配置日志级别，只能允许大于配置级别的日志通过appender</li>
<li>TimeFilter过滤时间，一些高峰期内(某个时间段)的日志不输出日志</li>
</ol>
<p>Filter有三种判定结果，ACCEPT；DENY；NEUTRAL；可以配置多个Filter，当一个Filter的返回结果是ACCEPT，不执行下一个Filter直接通过Appender；返回DENY直接drop掉；返回NEUTRAL则继续下一个Filter判定。</p>
<ol>
<li>ACCEPT接受</li>
<li>DEENY拒绝</li>
<li>NEUTRAL中立</li>
</ol>
<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>log4j2支持用户自定义组件，他所有的组件(Appender、Layout,…)都是Plugin，包括原生组件。在类声明前加上@Plugin标签来声明该类是一个插件，在初始化期间，Configuration会加载PluginManager来加载log4j2插件，包括用户自定义插件。<br>PluginManager通过5中方式来定位插件，详情可见<a href="http://logging.apache.org/log4j/2.x/manual/plugins.html" target="_blank" rel="external">官网Plugin加载</a>，其中默认的是利用了AbstractProccessor，该类在编译期会将所有的Plugin再加到文件<code>META-INF/org/apache/logging/log4j/core/config/plugins/Log4j2Plugins.dat</code>下，PluginManager会读该文件加载插件。</p>
<hr>
<p>参考资料：</p>
<ol>
<li><a href="https://www.slf4j.org/" target="_blank" rel="external">slf4j官网</a></li>
<li><a href="http://logging.apache.org/log4j/2.x/index.html" target="_blank" rel="external">log4j2官网</a></li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2018/08/13/Java日志体系/" data-id="ck0rmjfz5000ykg1bag5frbag" class="article-share-link">分享</a><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a href="/2019/09/20/征迁小总结/" class="pre">征迁小总结</a><a href="/2018/07/26/maven详解/" class="next">maven详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/flume/" style="font-size: 15px;">flume</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/es/" style="font-size: 15px;">es</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/20/征迁小总结/">征迁小总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/Java日志体系/">Java日志体系</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/maven详解/">maven详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/Flume源码-组件内部结构/">Flume源码-组件内部结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/18/Linux-oom-killer详解及应用/">Linux-oom killer详解及应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/13/Linux-cgroup/">Linux-cgroup隔离cpu资源</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/12/Flume源码-工作流程/">Flume源码-工作流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/Java学习-ThreadLocal/">Java学习-ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/Elasticsearch基础/">Elasticsearch基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/Java学习-Nio-Selector/">Java学习-Nio Selector</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://tech.meituan.com/" title="美团点评技术团队" target="_blank">美团点评技术团队</a><ul></ul><a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a><ul></ul><a href="http://cherry1084.giyhub.io/" title="爱小晴个人博客未来站点" target="_blank">爱小晴个人博客未来站点</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">JunDa Chen's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>